@inherits Patternfly.Components.Base.PatternflyComponentBase
@typeparam TItem
@using Outrage.Patternfly.Components.Utilities

<div class="@Classes" @attributes="AdditionalAttributes">
    <span id="@id.With("select-single-typeahead-expanded-label")" hidden>New</span>

    <div class="pf-c-select__toggle pf-m-typeahead">
        <div class="pf-c-select__toggle-wrapper">
            <input class="pf-c-form-control pf-c-select__toggle-typeahead"
                   type="text"
                   id="@id.With("select-single-typeahead-expanded-typeahead")"
                   aria-label="Type to filter"
                   placeholder="@Placeholder"
                   @bind-value="this.Text" @bind-value:event="oninput" />
        </div>
        @if (OnItemCreated.HasDelegate && !String.IsNullOrEmpty(this.text))
        {
            <button class="pf-c-button pf-m-plain pf-c-select__toggle-clear"
                type="button"
                aria-label="Clear all"
                @onclick="CreateItem">
                <Icon Name="@IconCheck" Size="@IconSize" Weight="@IconWeight" Library="@IconLibrary" />
            </button>
        }

        @if (!String.IsNullOrEmpty(this.text))
        {
            <button class="pf-c-button pf-m-plain pf-c-select__toggle-clear"
                type="button"
                aria-label="Clear all"
                @onclick="ClearSearch">
                <Icon Name="@IconClear" Size="@IconSize" Weight="@IconWeight" Library="@IconLibrary" />
            </button>
        }

        <button class="pf-c-button pf-m-plain pf-c-select__toggle-button"
                type="button"
                id="@id.With("select-single-typeahead-expanded-toggle")"
                aria-haspopup="true"
                aria-expanded="true"
                aria-labelledby="@id.With("select-single-typeahead-expanded-label") @id.With("select-single-typeahead-expanded-toggle")"
                aria-label="Select"
                @onclick="ToggleExpanded">
            <Icon Name="@IconCaret" class="pf-c-select__toggle-arrow" Size="@IconSize" Weight="@IconWeight" Library="@IconLibrary" />
        </button>
    </div>

    <ul class="pf-c-select__menu"
        aria-labelledby="@id.With("select-single-typeahead-expanded-label")"
        role="listbox"
        hidden="@(!Expanded)">
        @foreach (var item in MatchedItems)
        {
            var value = item?.ToString();
            if (value != null)
            {
                var mark = value.Substring(0, Math.Min(this.text.Length, value.Length));
                var notmark = value.Substring(Math.Min(value.Length, this.text.Length));
                <li role="presentation" @key="item">
                    <button class="pf-c-select__menu-item" role="option" @onclick="() => SelectItem(item!)">
                        <mark class="pf-c-select__menu-item--match">@mark</mark>@notmark

                        @if (item?.Selected ?? false)
                        {
                            <span class="pf-c-select__menu-item-icon">
                                <Icon Name="@IconCheck" Size="@IconSize" Weight="@IconWeight" Library="@IconLibrary" />
                            </span>
                        }

                    </button>
                </li>
            }
        }
    </ul>
</div>

@code {

    string text = "";
    IEnumerable<TypeaheadItem<TItem>> MatchedItems { get; set; } = Enumerable.Empty<TypeaheadItem<TItem>>();

    [Parameter]
    public string Text
    {
        set
        {
            this.text = value;
            this.SearchItem();
        }
        get { return this.text; }
    }

    [Parameter] public bool Expanded { get; set; } = false;
    [Parameter] public string Placeholder { get; set; } = "New";
    [Parameter] public IEnumerable<TypeaheadItem<TItem>> Items { get; set; } = Enumerable.Empty<TypeaheadItem<TItem>>();
    [Parameter] public EventCallback<TypeaheadItem<TItem>> OnItemSelected { get; set; }
    [Parameter] public EventCallback<TypeaheadItem<TItem>> OnItemCleared { get; set; }
    [Parameter] public EventCallback<string> OnItemCreated { get; set; }
    [Parameter] public string IconCheck { get; set; } = "check";
    [Parameter] public string IconClear { get; set; } = "times-circle";
    [Parameter] public string IconCaret { get; set; } = "caret-down";
    [Parameter] public Icon.SizeEnum IconSize { get; set; } = Icon.SizeEnum.regular;
    [Parameter] public Icon.LibraryEnum IconLibrary { get; set; } = Icon.LibraryEnum.fontawesome;
    [Parameter] public Icon.WeightEnum IconWeight { get; set; } = Icon.WeightEnum.solid;

    public IEnumerable<TypeaheadItem<TItem>> SelectedItems => Items.Where(r => r.Selected);

    public HtmlId id = new();

    protected override IEnumerable<string> OnIntroduceClasses()
    {
        var classes = new HashSet<string>(new string[] { "pf-c-select" });
        if (Expanded)
        {
            classes.Add("pf-m-expanded");
        }

        return classes;
    }

    public async void ClearSearch()
    {
        await OnItemCleared.InvokeAsync();
        this.ClearSelections();
        this.text = String.Empty;
        this.Expanded = false;
        this.StateHasChanged();
    }

    public Task ToggleExpanded()
    {
        this.Expanded = !this.Expanded;
        if (this.Expanded)
            this.SearchItem();

        return Task.CompletedTask;
    }

    public void SearchItem()
    {
        this.MatchedItems = this.Items;
        if (!String.IsNullOrEmpty(this.text))
            this.MatchedItems = this.Items.Where(r => (r?.ToString() ?? "").StartsWith(this.text, StringComparison.CurrentCultureIgnoreCase));

        if (this.MatchedItems.Any())
            this.Expanded = true;

        this.StateHasChanged();
    }

    protected void ClearSelections()
    {
        foreach (var resetItem in this.Items)
        {
            resetItem.Selected = false;
        }
    }

    protected async Task SelectItem(TypeaheadItem<TItem> item)
    {
        this.ClearSelections();
        await this.OnItemSelected.InvokeAsync(item);
        item.Selected = true;
        this.Text = item.ToString();
        this.Expanded = false;
    }

    public async Task CreateItem()
    {
        await this.OnItemCreated.InvokeAsync(this.text);
        this.Text = "";
        this.Expanded = false;
    }
}
