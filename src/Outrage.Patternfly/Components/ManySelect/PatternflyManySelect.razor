@using Outrage.EventBus;
@using Outrage.Patternfly.Components.ManySelect
@inject IServiceProvider serviceProvider
@typeparam TKey

<CascadingValue Name="SelectParent" Value="this">
    <div class="pf-c-select @(toggled?"pf-m-expanded":"")">
        <div class="pf-c-select__toggle" @onclick="Toggle" @onclick:stopPropagation>
            <div class="pf-c-select__toggle-wrapper">
                @Viewer
            </div>
            <button class="pf-c-button pf-m-plain pf-c-select__toggle-button"
                    type="button"
                    aria-haspopup="true"
                    aria-expanded="@toggled">
                <span class="pf-c-select__toggle-arrow">
                    <i class="fas fa-caret-down" aria-hidden="true"></i>
                </span>
            </button>
        </div>

        @if (toggled)
        {
            @Finder
        }
    </div>
</CascadingValue>

@code {
    bool toggled = false;
    public IEventAggregator? EventAggregator { get; set; }
    [Parameter] public HashSet<TKey> Value { get; set; } = default!;
    [Parameter] public EventCallback<HashSet<TKey>> ValueChanged { get; set; }
    [Parameter] public bool CloseOnSelect { get; set; } = true;

    protected override void OnInitialized()
    {
        EventAggregator = new Outrage.EventBus.Predefined.RootEventBus(serviceProvider);

        base.OnInitialized();
    }

    [Parameter]
    public RenderFragment? Viewer { get; set; }

    [Parameter]
    public RenderFragment? Finder { get; set; }

    void Toggle()
    {
        toggled = !toggled;
        StateHasChanged();
    }

    public async Task SetKeysAsync(params TKey?[] keys)
    {
        
        this.Value.Clear();
        foreach (var key in keys)
        {
            if (key != null)
                this.Value.Add(key);
        }
        if (this.EventAggregator != null)
            await this.EventAggregator.PublishAsync(new ManySelectKeysChangedMessage<TKey>(this.Value));

        await ValueChanged.InvokeAsync(this.Value);
        CloseSingle();
    }

    public async Task AddKeyAsync(TKey? key)
    {
        if (key != null)
        {
            this.Value.Add(key);
            if (this.EventAggregator != null)
                await this.EventAggregator.PublishAsync(new ManySelectKeysChangedMessage<TKey>(this.Value));

            await ValueChanged.InvokeAsync(this.Value);
        }
    }
    
    public async Task RemoveKeyAsync(TKey? key)
    {
        if (key != null)
        {
            this.Value.Remove(key);
            if (this.EventAggregator != null)
                await this.EventAggregator.PublishAsync(new ManySelectKeysChangedMessage<TKey>(this.Value));

            await ValueChanged.InvokeAsync(this.Value);
        }
    }

    public async Task ToggleKeyAsync(TKey? key)
    {
        if (key != null)
        {
            if (this.Value.Contains(key))
                this.Value.Remove(key);
            else
                this.Value.Add(key);
            if (this.EventAggregator != null)
                await this.EventAggregator.PublishAsync(new ManySelectKeysChangedMessage<TKey>(this.Value));

            await ValueChanged.InvokeAsync(this.Value);
            CloseSingle();
        }
    }

    public async Task ClearKeysAsync()
    {
        this.Value.Clear();
        if (this.EventAggregator != null)
            await this.EventAggregator.PublishAsync(new ManySelectKeysChangedMessage<TKey>(this.Value));

        await ValueChanged.InvokeAsync(this.Value);
        CloseSingle();
    }

    public bool IsKeySelected(TKey key)
    {
        return this.Value.Contains(key);
    }

    public async void CloseSingle()
    {
        if (this.CloseOnSelect && toggled)
        {
            toggled = false;
        }
        await InvokeAsync(StateHasChanged);
    }
}